#For additional raycasting & viewing visit these two scratch links : 
#https://scratch.mit.edu/projects/858285273/
#https://scratch.mit.edu/projects/853747688/
#This is an upload of one of my oldest python project, at the time, I did not know how to use OOP to organise my code so yeah, a bit messy isn't it.

import pygame as pg
import sys
import math

# Khởi tạo màn hình
screenx , screeny = 600,600
screen = pg.display.set_mode((screenx,screeny))
pg.display.set_caption("Player Movement Demo")

# Biến toàn cục
running = True
color = 0
height, width = 20, 45
angle = 0
step = 5
TILE = 30
FOV = 45
camx = 300
camy = 300
delta_angle = 0.5
setup_x= 0
# Bản đồ
map = [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
       [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
       [1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
       [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
       [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
       [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
       [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
       [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
       [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
       [1,0,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
       [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1],
       [1,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
       [1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
       [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1],
       [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
       [1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
       [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
       [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
       [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
       [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]]
def setup_coordinate(x_tile, y_tile) : 
    global real_px, real_py,px,py
    real_px = (x_tile-1)*TILE + TILE/2
    real_py = (y_tile-1)*TILE +TILE/2

def switch_coordinate() : 
    global px, py, real_px, real_py, camx,camy,tilex, tiley
    tilex = int(real_px//TILE)
    tiley = int(real_py//TILE)
    px = real_px - camx + screenx/2
    py = real_py - camy + screeny/2

def cast_horizontal_ray(alpha):
    global real_px,real_py,dh,hix,hiy,tilex,tiley
    dh = float('inf')
    sin_a = math.sin(alpha)
    if abs(sin_a) < 1e-3 : 
        return
    elif sin_a > 0 : 
        first_wall_y = tiley*TILE+TILE ####
        dy = TILE
        oy = 0 #Chính xác từ đầu rồi nên oy = 0
    else : 
        first_wall_y = tiley*TILE ####
        dy = -TILE
        oy = -1 
    dx = dy/math.tan(alpha)
    hix = real_px + (first_wall_y - real_py)/math.tan(alpha)
    hiy = first_wall_y
    while 0<= int(hix // TILE) < width and 0<= int(hiy //TILE) < height: 
        if map[int((hiy+oy)//TILE)][int(hix//TILE)] == 1:
                break
        hix += dx
        hiy += dy
    dh = abs((real_py-hiy)/math.sin(alpha))

def cast_vertical_ray(theta):
    global real_px,real_py,dv,vix,viy,tilex,tiley
    dv = float('inf')
    cos_a = math.cos(theta)
    if abs(cos_a) <1e-3 : 
        return
    elif cos_a > 0 :
        first_wall_x = tilex*TILE+TILE 
        dx = TILE
        ox =0
    else : 
        first_wall_x = tilex*TILE 
        dx = -TILE
        ox = -1
    vix = first_wall_x
    viy = real_py+ math.tan(theta)*(first_wall_x-real_px) #Nhớ cộng py vì là vị trí giao đầu tiên
    dy = dx*math.tan(theta)
    while 0<= int(vix//TILE)+ox < width and 0<= int(viy//TILE) <height : 
        if map[int(viy//TILE)][int(vix//TILE)+ox] ==1 : 
            break
        vix += dx
        viy += dy
    dv = abs((vix-real_px)/math.cos(theta))

def cast_ray(input_angle) : 
    global dh,dv
    cast_horizontal_ray(input_angle)
    cast_vertical_ray(input_angle)
    if dh > dv : 
        pg.draw.line(screen, 'yellow', (px, py), (vix-camx+screenx/2, viy-camy+screeny/2), 1)
    else : pg.draw.line(screen, 'yellow', (px, py), (hix-camx+screenx/2, hiy-camy+screeny/2), 1)

def draw_map():
    global color, px, py, real_px, real_py,tilex,tiley
    y1,x1 = tiley-10, tilex-10
    y2,x2 = tiley+11,tilex+11
    if y1 < 0 : y1 = 0 
    if y2>len(map)-1 : y2 = len(map)
    if x1<0 : x1=0
    if x2>len(map)-1 : x2 = 45
    for i in range(y1, y2) :
        for k in range(x1, x2):
            if map[i][k] ==0 : color = 'white'
            elif map[i][k] == -1 : continue
            else : color = 'black'
            x = k*TILE+screenx/2-int(camx)
            y = i*TILE + screeny/2 - int(camy)
            pg.draw.rect(screen, color, (x,y, TILE-1, TILE-1))
    pg.draw.circle(screen, 'green', (px, py), 4)

def collision_move() : 
    global pdx, pdy,real_px,real_py,camx,camy,tilex,tiley
    tile_offset_x = int((real_px+pdx)//TILE) ###
    tile_offset_y = int((real_py+pdy)//TILE) ###
    if map[tiley][tile_offset_x] != 0 :
        pdx = 0
    if map[tile_offset_y][tilex] !=0 : 
        pdy = 0
    real_px += pdx
    real_py += pdy
    camx,camy = real_px,real_py
# Vòng lặp chính
def cast_multiple_rays() : 
    a = angle - math.radians(FOV/2)
    for _ in range(0,int(FOV/delta_angle)) : #gạch dưới là biến khoong cần sử dụng
        cast_ray(a)
        a+= math.radians(delta_angle)
clock = pg.time.Clock()


while running:
    if setup_x == 0 : 
        setup_coordinate(35,10)
        camx = real_px
        camy = real_py
        setup_x +=1
    switch_coordinate()
    for event in pg.event.get():
        if event.type == pg.QUIT:
            running = False
    pressing = pg.key.get_pressed()
    if pressing[pg.K_LEFT]:
        angle -= math.radians(5)
    if pressing[pg.K_RIGHT]:
        angle += math.radians(5)
    if pressing[pg.K_UP]:
        pdx = step * math.cos(angle)
        pdy = step * math.sin(angle)
        collision_move()
    if pressing[pg.K_DOWN]:
        pdx = -step * math.cos(angle)
        pdy = -step * math.sin(angle)
        collision_move()

    screen.fill('grey')
    draw_map()
    cast_multiple_rays()
    pg.display.flip()
    clock.tick(60)  # Giới hạn tốc độ khung hình

# Thoát
pg.quit()
sys.exit()

#player_onscreen = player_world- cam coordinate + width/height screen
